# Архитектура


## Ввод и графика
Используем **PyGame**.
Там точно есть запросы событий ввода, таймер и отрисовка спрайтов.
Упаковываем всё это в АТД `Engine`, `Input` и `Renderer`.


## Работа с игровым полем

### Начало новой игры
1. удалить из мира все сущности, содержащиеся в игровом поле;
1. создать новое игровое поле нужного размера;
1. для каждого элемента уровня:
    1. создать сущность в клетке игрового поля;
    1. добавить к сущности компоненты из элемента;


### Загрузка сохранения
1. удалить из мира все сущности, содержащиеся в игровом поле;
1. создать новое игровое поле нужного размера;
1. для каждой сущности из сохранения:
    1. создать новую сущность;
    1. скопировать в новую сущность компоненты;
    1. разместить сущность в игровом поле на основе значений компонентов;


### Перемещение сущностей
При начале движения (добавлении компонента `FieldMotion`):
- добавить входящую сущность в соседнюю клетку;

При завершении движения:
- удалить сущность из начальной клетки;
- добавить сущность в конечную клетку;
- удалить входящую сущность из конечной клетки;

При удалении сущности:
- удалить из начальной клетки;
- если есть `FieldMotion` - удалить из конечной клетки;


### P.S.
Нужен новый АТД - `GameWorld`, который инкапсулирует `World` и `GameField`.
В нём добавление и удаление компонентов `FieldPosition` и `FieldMotion`
будут правильно отрабатываться в `GameField`.

Получается, что есть низкоуровневые механизмы - компоненты, и абстракции,
которые их используют.


## Интерфейс
Элементы интерфейса - тоже часть мира.
Для них нужны отдельные системы для отображения меню и игровых очков.


## Работа систем

Все системы запускаются последовательно.

Следует различать ситуации **пусто** и **нет препятствия**.

**Пусто** - это вообще нет сущности.

**Нет препятствия** - это **пусто**, или сущность,
переместившаяся в другую клетку больше, чем наполовину.

**Есть препятствие** - это неподвижная сущность,
или сущность переместившаяся в другую клетку меньше, чем наполовину,
или сущность, перемещающаяся в эту клетку.

Компоненты воздействия (`Hit`, `Bite`, `Burn`) содержат координаты клетки
воздействия, чтобы знать где рисовать взрыв, если что.


### `MotionSystem`
1. выбрать в мире все сущности с компонентом `FieldMotion`;
1. изменить степень перемещения в соответствии с таймером;
1. если перемещение завершено - переместить сущность между клетками на игровом поле;


### `FallingSystem`
1. выбрать в мире все сущности с компонентом `Falling` и `FieldMotion`;
1. если движение в `FieldMotion` завершено
    1. если снизу есть препятствие -
        добавить компонент `Hit` к этой сущности и препятствию;
    1. удалить компонент `FieldMotion`;


### `StartFallingSystem`
1. выбрать в мире все сущности с компонентом `Falling` и без `FieldMotion`;
1. для всех сущностей, где снизу пусто - добавить компонент
    `FieldMotion` с движением вниз;


### `StartRollingSystem`
1. выбрать в мире все сущности с компонентом `Rolling` и без `FieldMotion`;
1. для всех сущностей, где снизу круглое неподвижное препятствие:
    1. если справа и справа внизу пусто - добавить `FieldMotion` с движением вправо;
    1. иначе если слева и слева внизу пусто - добавить `FieldMotion` с движением влево;


### `TurningSystem`
1. выбрать в мире все сущности с компонентом `Turning`;
1. изменить степень поворота в соответствии с таймером;
1. если поворот завершён - убрать компонент `Turning`;


### `SeekRightSystem`
1. выбрать в мире все сущности с компонентом `RoamingRight`
    без `FieldMotion` и `Turning`;
1. если справа от направления движения (компонент `Direction`) пусто -
    добавить компонент `Turning` с поворотом вправо и пропустить оставшиеся пункты;
1. если справа препятствие - добавить препятствию компонент `Bite`;
1. если спереди пусто - добавить компонент `FieldMotion` в направлении движения
    и пропустить оставшиеся пункты;
1. если спереди препятствие - добавить препятствию компонент `Bite`;
1. добавить компонент `Turning` с поворотом влево;    


### `SeekLeftSystem`
То же, что и `SeekRightSystem`, только зеркально.


### `ControlSystem`
1. найти сущность с компонентом `PlayerControl`;
1. если нет команд от игрока - очистить команды (`Step`, `Push`) на сущности;
1. если команда от игрока совпадает по направлению с командой на сущности -
    оставить всё как есть;
1. если есть команды от игрока, но нет команд на сущности -
    добавить сущности компонент `Step` с соответствующим направлением;


### `PushSystem`
1. выбрать сущность с компонентом `Push`;
1. изменить степень толчка в соответствии с таймером;
1. если толчок завершён и не возникло препятствий за толкаемым объектом -
    добавить компоненты `FieldMotion` игроку и толкаемому объекту
    и удалить компонент `Push`;


### `StepSystem`
1. выбрать сущность с компонентом `Step`;
1. если в указанном направлении пусто - добавить компонент `FieldMotion`;
1. если в указанном направлении сущность с компонентом `Consumable` -
    добавить компонент `FieldMotion` сущности с компонентом `Step`
    и `Consumed` тому, кого съели;
1. если в указанном направлении сущность с компонентом `Pushable`, а за ней пусто -
    добавить компонент `Push` сущности с компонентом `Step`;
1. если в указанном направлении сущность с компонентом `Biting` -
    добавить компонент `Bite` сущности с компонентом `Step`;
1. если в указанном направлении сущность с компонентами `Falling` и `FieldMotion` -
    добавить компонент `Hit` сущности с компонентом `Step`;
1. если в указанном направлении сущность с компонентом `Burning` -
    добавить компонент `Burn` сущности с компонентом `Step`;


### `BiteSystem`
1. выбрать в мире все сущности с компонентом `Bite`;
1. удалить у сущностей компонент `Bite`;
1. если есть компонент `BiteDestructible` - добавить компонент `Destroyed`;


### `HitSystem`
1. выбрать в мире все сущности с компонентом `Hit`;
1. удалить у сущностей компонент `Hit`;
1. если есть компонент `HitDestructible` - добавить компонент `Destroyed`;


### `BurnSystem`
1. выбрать в мире все сущности с компонентом `Burn`;
1. удалить у сущностей компонент `Burn`;
1. если есть компонент `BurnDestructible` - добавить компонент `Destroyed`;


### `ExplosionSystem`
1. выбрать в мире все сущности с компонентом `Destroyed`;
1. удалить сущность с поля и заменить взрывом;
1. если есть компонент `Explosive` - добавить компонент `Burn` всем соседям;


### `ScoreSystem`
1. выбрать сущность с компонентами `Consumed` и `Score`;
1. если нашли - увеличить счёт;


### `ConsumeSystem`
1. выбрать сущность с компонентом `Consumed`;
1. добавить ей компонент `Destroyed`;


### `CleaningSystem`
1. выбрать в мире все сущности с компонентом `Destroyed`;
1. удалить выбранные сущности из мира;


### `CameraSystem`
1. выбрать сущность с компонентом `CameraFollow`;
1. вычислить координаты области поля, которая отображается на экране;
1. выбрать в мире все сущности с компонентом `FieldPosition`;
1. вычислить экранные координаты в соответствие с `FieldPosition` и `FieldMotion`;


### `ScoreShowSystem`
Управляет отображением счёта.


### `RenderingSystem`
1. выбрать в мире все сущности с компонентом `Sprite` и `ScreenPosition`;
1. отобразить все спрайты;
1. выбрать в мире все сущности с компонентом `Text` и `ScreenPosition`;
1. отобразить все текстовые объекты;


## Тесты для систем
Для каждого сценария нужно создать небольшой мир и проверить,
что отдельная система отработала корректно.

Потом нужно также протестировать последовательности систем.
